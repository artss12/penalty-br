<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>FIFA Retro - Brasileirão (mobile)</title>
<style>
  :root{background:#0b7a3a;color:#fff;font-family:monospace}
  html,body{height:100%;margin:0;padding:0;}
  #gameWrap{display:flex;flex-direction:column;height:100vh;align-items:center;justify-content:flex-start}
  canvas#game{background:#0a5a2b;border:6px solid #002400;border-radius:8px;margin-top:6px;touch-action:none}
  #ui{width:100%;max-width:720px;padding:6px;box-sizing:border-box;display:flex;gap:8px;align-items:center;justify-content:space-between}
  .panel{background:rgba(0,0,0,0.4);padding:6px;border-radius:6px}
  #controls{position:fixed;left:0;right:0;bottom:8px;display:flex;justify-content:space-between;padding:0 12px;pointer-events:none}
  .pad{width:45%;max-width:320px;pointer-events:auto}
  #joystick{height:140px;position:relative}
  .stickBase{position:absolute;left:8px;bottom:8px;width:120px;height:120px;border-radius:60px;background:rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center}
  .stickKnob{width:48px;height:48px;border-radius:24px;background:rgba(255,255,255,0.12)}
  .buttons{display:flex;flex-direction:column;gap:12px;align-items:flex-end;pointer-events:auto}
  .btn{width:74px;height:74px;border-radius:38px;background:rgba(255,255,255,0.08);display:flex;align-items:center;justify-content:center;font-weight:700;font-size:14px}
  #tablePanel{position:fixed;left:8px;top:8px;background:rgba(0,0,0,0.45);padding:8px;border-radius:8px;max-height:60vh;overflow:auto}
  table{border-collapse:collapse;color:#fff;font-size:12px}
  td,th{padding:4px 6px;border-bottom:1px solid rgba(255,255,255,0.06)}
  .small{font-size:11px;opacity:0.9}
  #topBar{width:100%;max-width:720px;display:flex;justify-content:space-between;align-items:center;margin-top:8px}
  #msg{background:rgba(0,0,0,0.4);padding:6px;border-radius:6px}
  @media (min-width:600px){#controls{padding:0 40px}}
</style>
</head>
<body>
<div id="gameWrap">
  <div id="topBar">
    <div class="panel" id="msg">Brasileirão - FIFA Retro (toque: joystick + passe/chute)</div>
    <div class="panel" id="score">Tempo: <span id="timeLabel">00:00</span> | Placar: <span id="scoreLabel">0 - 0</span></div>
  </div>
  <canvas id="game" width="720" height="400"></canvas>
  <div id="controls">
    <div class="pad" id="leftPad">
      <div id="joystick">
        <div class="stickBase" id="stickBase">
          <div class="stickKnob" id="stickKnob"></div>
        </div>
      </div>
    </div>
    <div class="pad" id="rightPad">
      <div class="buttons">
        <div class="btn" id="shootBtn">CHUTE</div>
        <div class="btn" id="passBtn">PASSE</div>
      </div>
    </div>
  </div>
  <div id="tablePanel" class="panel">
    <strong>Tabela - Brasileirão (demo)</strong>
    <div id="leagueTable"></div>
  </div>
</div>

<script>
/*
  Jogo retrô top-down para mobile. Código compacto, comentado e modular.
  Limitações: assets desenhados em canvas (sprite simples). Times do Brasileirão listados com cores primárias.
*/

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

// --- Configs ---
const config = {
  maxPlayersPerTeam: 6,
  matchMinutes: 3, // cada partida curta para demo
  fps: 60,
  joystickRadius: 40,
  ballFriction: 0.992,
  difficulty: 'hard' // 'easy'|'medium'|'hard'
}

// --- Brasileirão (nomes e cores simples) ---
const teams = [
  {name:'Flamengo', color:'#ff1f1f'}, {name:'Palmeiras', color:'#008f39'}, {name:'São Paulo', color:'#ffffff', alt:'#000'},
  {name:'Grêmio', color:'#1e90ff'}, {name:'Athletico-PR', color:'#c00000'}, {name:'Corinthians', color:'#111'},
  {name:'Atlético-MG', color:'#000'}, {name:'Fortaleza', color:'#0066cc'}, {name:'Botafogo', color:'#f0f0f0', alt:'#000'},
  {name:'Fluminense', color:'#009933'}, {name:'Vasco', color:'#000'}, {name:'Internacional', color:'#cc0000'},
  {name:'Cuiabá', color:'#ffcc00'}, {name:'Ceará', color:'#222'}, {name:'Sport', color:'#ff6600'},
  {name:'Goiás', color:'#66cc33'}, {name:'Coritiba', color:'#1b5e20'}, {name:'Avaí', color:'#0033cc'},
  {name:'Atlético-GO', color:'#990000'}, {name:'Santos', color:'#fff', alt:'#000'}
];

// --- Utility ---
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y)}

// --- Game state ---
const state = {
  home: null,
  away: null,
  players: [],
  ball: null,
  time: 0,
  running: true,
  score: {home:0, away:0},
  possession: null,
  league: [],
}

// --- Entities ---
class Ball{
  constructor(x,y){this.x=x;this.y=y;this.vx=0;this.vy=0;this.radius=6}
  update(){
    this.x += this.vx; this.y += this.vy;
    this.vx *= config.ballFriction; this.vy *= config.ballFriction;
    // keep in field bounds
    const pad = 16;
    if(this.x < pad) { this.x = pad; this.vx *= -0.6 }
    if(this.x > W - pad) { this.x = W-pad; this.vx *= -0.6 }
    if(this.y < pad) { this.y = pad; this.vy *= -0.6 }
    if(this.y > H - pad) { this.y = H-pad; this.vy *= -0.6 }
  }
  draw(ctx){
    ctx.save(); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fill(); ctx.restore();
  }
}

class Player{
  constructor(x,y,team,isUser=false){
    this.x=x; this.y=y; this.vx=0; this.vy=0; this.team=team; this.isUser=isUser;
    this.radius=10; this.speed= (isUser?1.6:1.25);
    this.hasBall=false; this.number=0; this.stamina=100;
  }
  update(dt){
    this.x += this.vx * dt; this.y += this.vy * dt;
    // simple damp
    this.vx *= 0.9; this.vy *= 0.9;
    this.x = clamp(this.x, 24, W-24); this.y = clamp(this.y, 24, H-24);
  }
  draw(ctx){
    ctx.save();
    // body
    ctx.beginPath(); ctx.fillStyle=this.team.color; ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fill();
    // number
    ctx.fillStyle=this.team.alt||'#000'; ctx.font='10px monospace'; ctx.textAlign='center'; ctx.fillText(this.number||'',this.x,this.y+3);
    // ball indicator
    if(this.hasBall){ ctx.beginPath(); ctx.arc(this.x+14,this.y-10,4,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill(); }
    ctx.restore();
  }
}

// --- Initialize match ---
function initMatch(homeIdx=0, awayIdx=1){
  state.home = teams[homeIdx]; state.away = teams[awayIdx];
  state.players = [];
  // create players (6 vs 6) including user-controlled striker at bottom
  const leftX = 120, rightX = W-120;
  for(let i=0;i<config.maxPlayersPerTeam;i++){
    let y = 60 + i*( (H-120)/(config.maxPlayersPerTeam-1) );
    let p1 = new Player(leftX, y, state.home, false); p1.number = i+1; state.players.push(p1);
    let p2 = new Player(rightX, y, state.away, false); p2.number = i+11; state.players.push(p2);
  }
  // make bottom-most home player the user
  const user = state.players[ config.maxPlayersPerTeam-1 ]; user.isUser = true; user.speed = 1.8;
  // ball center
  state.ball = new Ball(W/2, H/2);
  // give ball to a random player
  const idx = Math.floor(Math.random()*state.players.length);
  state.players[idx].hasBall=true; state.possession = state.players[idx];
  state.time = 0; state.score.home=0; state.score.away=0;
  buildLeagueTable();
}

// --- League (simple round robin demo) ---
function buildLeagueTable(){
  state.league = teams.map(t=>({name:t.name, pts:0, g:0, w:0,d:0,l:0,gd:0}));
  renderLeagueTable();
}
function renderLeagueTable(){
  const container = document.getElementById('leagueTable');
  let html = '<table><thead><tr><th>#</th><th>Time</th><th>P</th><th>W</th><th>D</th><th>L</th><th>+/-</th></tr></thead><tbody>';
  state.league.slice(0,10).forEach((r,i)=>{
    html += `<tr><td>${i+1}</td><td>${r.name}</td><td>${r.pts}</td><td>${r.w}</td><td>${r.d}</td><td>${r.l}</td><td>${r.gd}</td></tr>`;
  });
  html += '</tbody></table>';
  container.innerHTML = html;
}

// --- Controls (joystick + buttons) ---
const stickBase = document.getElementById('stickBase');
const stickKnob = document.getElementById('stickKnob');
let joystick = {active:false,dx:0,dy:0,angle:0,magnitude:0};
let activeTouchId = null;

function resetKnob(){ stickKnob.style.transform = 'translate(0px,0px)'; }

stickBase.addEventListener('touchstart',e=>{
  e.preventDefault(); const t = e.changedTouches[0]; activeTouchId = t.identifier; joystick.active=true; updateJoystickFromTouch(t);
});
stickBase.addEventListener('touchmove',e=>{ e.preventDefault(); for(const t of e.changedTouches) if(t.identifier===activeTouchId) updateJoystickFromTouch(t); });
stickBase.addEventListener('touchend',e=>{ e.preventDefault(); for(const t of e.changedTouches) if(t.identifier===activeTouchId){ joystick.active=false; joystick.dx=0;joystick.dy=0; activeTouchId=null; resetKnob(); } });

function updateJoystickFromTouch(t){ const rect = stickBase.getBoundingClientRect(); const cx = rect.left + rect.width/2; const cy = rect.top + rect.height/2; const dx = t.clientX - cx; const dy = t.clientY - cy; const max = 36; const mag = Math.hypot(dx,dy); const nx = clamp(dx, -max, max); const ny = clamp(dy, -max, max); joystick.dx = nx/max; joystick.dy = ny/max; joystick.magnitude = clamp(mag/max,0,1); stickKnob.style.transform = `translate(${nx}px,${ny}px)`; }

// Buttons
let passPressed=false, shootPressed=false;
const passBtn = document.getElementById('passBtn'), shootBtn = document.getElementById('shootBtn');
passBtn.addEventListener('touchstart',e=>{ e.preventDefault(); passPressed=true }); passBtn.addEventListener('touchend',e=>{ e.preventDefault(); passPressed=false });
shootBtn.addEventListener('touchstart',e=>{ e.preventDefault(); shootPressed=true }); shootBtn.addEventListener('touchend',e=>{ e.preventDefault(); shootPressed=false });

// For desktop testing also support mouse
stickBase.addEventListener('mousedown',e=>{ joystick.active=true; updateJoystickFromMouse(e); window.addEventListener('mousemove',updateJoystickFromMouse); });
window.addEventListener('mouseup',e=>{ joystick.active=false; joystick.dx=0;joystick.dy=0; resetKnob(); window.removeEventListener('mousemove',updateJoystickFromMouse); });
function updateJoystickFromMouse(e){ const rect = stickBase.getBoundingClientRect(); const cx = rect.left + rect.width/2; const cy = rect.top + rect.height/2; const dx = e.clientX - cx; const dy = e.clientY - cy; const max = 36; const nx = clamp(dx, -max, max); const ny = clamp(dy, -max, max); joystick.dx = nx/max; joystick.dy = ny/max; joystick.magnitude = clamp(Math.hypot(dx,dy)/max,0,1); stickKnob.style.transform = `translate(${nx}px,${ny}px)`; }

// --- Input application to user player ---
function applyControlsToUser(dt){
  const user = state.players.find(p=>p.isUser);
  if(!user) return;
  // joystick movement
  user.vx += joystick.dx * user.speed * dt * 2.5;
  user.vy += joystick.dy * user.speed * dt * 2.5;
  // actions
  if(passPressed && user.hasBall){ executePass(user); passPressed=false; }
  if(shootPressed && user.hasBall){ executeShot(user); shootPressed=false; }
}

// --- Actions: pass and shot ---
function executePass(player){
  // choose nearest teammate
  const team = player.team;
  const mates = state.players.filter(p=>p.team===team && p!==player);
  if(mates.length==0) return;
  // prefer forward teammate (towards opponent goal)
  const target = mates.reduce((a,b)=> (Math.abs(b.y-player.y) < Math.abs(a.y-player.y)? b:a));
  // kick ball towards target with moderate power
  kickBallTowards(player, target.x, target.y, 6 + Math.random()*2);
  player.hasBall=false;
}

function executeShot(player){
  // target goal x = center of opponent goal depending on team side
  const isLeft = (player.team===state.home);
  const gx = isLeft? W-8 : 8; const gy = H/2;
  kickBallTowards(player, gx, gy, 10 + Math.random()*4);
  player.hasBall=false;
}

function kickBallTowards(player, tx, ty, power){
  const b = state.ball;
  const dx = tx - b.x; const dy = ty - b.y; const d = Math.hypot(dx,dy)||1;
  b.vx = dx/d * power; b.vy = dy/d * power;
}

// --- AI ---
function aiUpdate(dt){
  const difficultyFactor = (config.difficulty==='hard')?1.2:(config.difficulty==='medium'?1.0:0.8);
  state.players.forEach(p=>{
    if(p.isUser) return;
    // simple behavior: if has ball -> try to shoot if close, else pass to open teammate or dribble toward goal
    if(p.hasBall){
      // if close to goal, shoot
      const isLeft = p.team===state.home;
      const goalX = isLeft? W-8 : 8; const gx = goalX; const gy = H/2;
      const dGoal = Math.hypot(p.x-gx,p.y-gy);
      if(dGoal < 120 * difficultyFactor && Math.random() < 0.6*difficultyFactor){ executeShot(p); }
      else if(Math.random() < 0.6){ // pass to best teammate
        const mates = state.players.filter(m=>m.team===p.team && m!==p);
        // pick mate with most open space (furthest from nearest opponent)
        let best = mates[0]; let bestScore=-Infinity;
        mates.forEach(m=>{
          const nearestOpp = nearestOppTo(m);
          const score = dist(m,nearestOpp) - Math.abs(m.y - H/2)/10;
          if(score>bestScore){ bestScore=score; best=m; }
        });
        if(best) kickBallTowards(p,best.x,best.y,6 + Math.random()*3); p.hasBall=false;
      } else { // dribble
        const dir = isLeft?1:-1; p.vx += dir * 0.8 * dt; }
    } else {
      // if near ball -> attempt to take it
      const d = Math.hypot(p.x-state.ball.x,p.y-state.ball.y);
      if(d < 26 + 4*difficultyFactor){
        // intercept: move towards ball aggressively
        const dx = state.ball.x - p.x; const dy = state.ball.y - p.y; const dd = Math.hypot(dx,dy)||1;
        p.vx += dx/dd * 1.6 * difficultyFactor * dt * 2; p.vy += dy/dd * 1.6 * difficultyFactor * dt * 2;
      } else {
        // positional behavior: defensive/offensive based on team side and ball position
        const ballOnLeft = state.ball.x < W/2;
        const shouldDefend = (p.team===state.home)? ballOnLeft : !ballOnLeft;
        const targetX = shouldDefend? 120 : W-120;
        // maintain vertical spread
        const idx = p.number % 6; const targetY = 60 + (idx)*((H-120)/(config.maxPlayersPerTeam-1));
        const dx = targetX - p.x; const dy = targetY - p.y; const dd = Math.hypot(dx,dy)||1;
        p.vx += dx/dd * 0.6 * dt; p.vy += dy/dd * 0.6 * dt;
      }
    }
  });
}

function nearestOppTo(player){
  const opponents = state.players.filter(p=>p.team!==player.team);
  let best = opponents[0]; let bd = dist(player,best);
  opponents.forEach(o=>{ const d = dist(player,o); if(d<bd){bd=d;best=o;} });
  return best;
}

// --- Collision / possession handling ---
function handleBallPossession(){
  const b = state.ball;
  // check for goals
  if(b.x < 12){ // left goal (away scores)
    scoreGoal('away'); resetAfterGoal(); return;
  }
  if(b.x > W-12){ scoreGoal('home'); resetAfterGoal(); return; }
  // ball-player collisions
  for(const p of state.players){
    const d = Math.hypot(p.x - b.x, p.y - b.y);
    if(d < p.radius + b.radius + 2){
      // take possession if close and ball moving slowly or player is closer than current possessor
      const current = state.possession;
      // impose contest rules
      if(!current || current===p || d < 14){
        // assign possession
        state.players.forEach(q=>q.hasBall=false);
        p.hasBall = true; state.possession = p;
        // stop ball
        b.vx = 0; b.vy = 0; b.x = p.x + (Math.random()*6-3); b.y = p.y + (Math.random()*6-3);
      } else {
        // contested: stronger chance for closer
        const dc = Math.hypot(current.x-b.x,current.y-b.y);
        if(d < dc){ state.players.forEach(q=>q.hasBall=false); p.hasBall=true; state.possession=p; b.vx=0; b.vy=0; }
      }
    }
  }
}

function scoreGoal(side){ if(side==='home') state.score.home++; else state.score.away++; updateScoreLabel(); }
function resetAfterGoal(){
  // simple reset: ball center, random possessor
  state.ball.x = W/2; state.ball.y = H/2; state.ball.vx = state.ball.vy = 0;
  state.players.forEach(p=>p.hasBall=false);
  const idx = Math.floor(Math.random()*state.players.length); state.players[idx].hasBall=true; state.possession = state.players[idx];
}

// --- UI updates ---
function updateScoreLabel(){ document.getElementById('scoreLabel').innerText = `${state.score.home} - ${state.score.away}`; }
function updateTimeLabel(){ const s = Math.floor(state.time); const mm = String(Math.floor(s/60)).padStart(2,'0'); const ss = String(s%60).padStart(2,'0'); document.getElementById('timeLabel').innerText = mm+':'+ss; }

// --- Game loop ---
let last = performance.now();
function loop(now){
  const dt = Math.min(1/30, (now-last)/1000);
  last = now;
  // update time
  state.time += dt;
  updateTimeLabel();

  // apply user input
  applyControlsToUser(dt);
  // ai
  aiUpdate(dt);

  // update players & ball
  state.players.forEach(p=>p.update(dt*60));
  state.ball.update();

  // if a player has the ball, keep ball attached
  const poss = state.players.find(p=>p.hasBall);
  if(poss){ state.ball.x = poss.x + 12; state.ball.y = poss.y - 6; state.ball.vx = 0; state.ball.vy = 0; }

  handleBallPossession();

  render();

  // match end condition
  const matchDuration = config.matchMinutes*60;
  if(state.time >= matchDuration){ // end match
    state.running = false; document.getElementById('msg').innerText = `Fim de partida. ${state.score.home} - ${state.score.away}`;
  }

  if(state.running) requestAnimationFrame(loop);
}

// --- Render ---
function render(){
  ctx.clearRect(0,0,W,H);
  drawField();
  // players sorted by y for depth
  const list = [...state.players].sort((a,b)=>a.y-b.y);
  list.forEach(p=>p.draw(ctx));
  state.ball.draw(ctx);
}

function drawField(){
  // grass tile
  ctx.fillStyle = '#2b8a46'; ctx.fillRect(0,0,W,H);
  // stripes
  for(let i=0;i<10;i++){ ctx.fillStyle = i%2? 'rgba(255,255,255,0.02)':'rgba(0,0,0,0.02)'; ctx.fillRect(i*(W/10),0,W/10,H); }
  // boundaries
  ctx.strokeStyle='#fff'; ctx.lineWidth=3; ctx.strokeRect(12,12,W-24,H-24);
  // center line
  ctx.beginPath(); ctx.moveTo(W/2,12); ctx.lineTo(W/2,H-12); ctx.stroke();
  // center circle
  ctx.beginPath(); ctx.arc(W/2,H/2,40,0,Math.PI*2); ctx.stroke();
  // goals
  ctx.fillStyle='#fff'; ctx.fillRect(0,H/2-30,12,60); ctx.fillRect(W-12,H/2-30,12,60);
}

// --- Resize handling ---
function fitCanvas(){
  const maxW = Math.min(window.innerWidth-16, 720);
  const scale = maxW / 720;
  canvas.style.width = Math.round(720*scale)+'px'; canvas.style.height = Math.round(400*scale)+'px';
}
window.addEventListener('resize', fitCanvas);

// --- Start ---
initMatch(0,1);
fitCanvas(); updateScoreLabel(); updateTimeLabel(); requestAnimationFrame(loop);

// --- Additional: simple keyboard for desktop testing ---
window.addEventListener('keydown',e=>{
  const user = state.players.find(p=>p.isUser);
  if(!user) return;
  if(e.key===' ') { if(user.hasBall) executeShot(user); }
});

</script>
</body>
</html>
